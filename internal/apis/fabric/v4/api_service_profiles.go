/*
Equinix Fabric API

Equinix Fabric is an advanced software-defined interconnection solution that enables you to directly, securely and dynamically connect to distributed infrastructure and digital ecosystems on platform Equinix via a single port, Customers can use Fabric to connect to: </br> 1. Cloud Service Providers - Clouds, network and other service providers.  </br> 2. Enterprises - Other Equinix customers, vendors and partners.  </br> 3. Myself - Another customer instance deployed at Equinix. </br>

API version: 4.2
Contact: api-support@equinix.com
*/

// Code generated by OpenAPI Generator (https://openapi-generator.tech); DO NOT EDIT.

package v4

import (
	"bytes"
	"context"
	"io/ioutil"
	"net/http"
	"net/url"
	"strings"
)


// ServiceProfilesApiService ServiceProfilesApi service
type ServiceProfilesApiService service

type ApiCreateServiceProfileRequest struct {
	ctx context.Context
	ApiService *ServiceProfilesApiService
	icVersion *string
	serviceProfileRequest *ServiceProfileRequest
}

// api version
func (r ApiCreateServiceProfileRequest) IcVersion(icVersion string) ApiCreateServiceProfileRequest {
	r.icVersion = &icVersion
	return r
}

func (r ApiCreateServiceProfileRequest) ServiceProfileRequest(serviceProfileRequest ServiceProfileRequest) ApiCreateServiceProfileRequest {
	r.serviceProfileRequest = &serviceProfileRequest
	return r
}

func (r ApiCreateServiceProfileRequest) Execute() (*ServiceProfile, *http.Response, error) {
	return r.ApiService.CreateServiceProfileExecute(r)
}

/*
CreateServiceProfile Create Service Profile

This API request creates a service profile which enables other Platform Equinix participants to connect and subscribe to your services.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiCreateServiceProfileRequest
*/
func (a *ServiceProfilesApiService) CreateServiceProfile(ctx context.Context) ApiCreateServiceProfileRequest {
	return ApiCreateServiceProfileRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ServiceProfile
func (a *ServiceProfilesApiService) CreateServiceProfileExecute(r ApiCreateServiceProfileRequest) (*ServiceProfile, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ServiceProfile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ServiceProfilesApiService.CreateServiceProfile")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/fabric/v4/serviceProfiles"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.icVersion == nil {
		return localVarReturnValue, nil, reportError("icVersion is required and must be specified")
	}
	if r.serviceProfileRequest == nil {
		return localVarReturnValue, nil, reportError("serviceProfileRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json; charset=UTF-8", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["Ic-Version"] = parameterToString(*r.icVersion, "")
	// body params
	localVarPostBody = r.serviceProfileRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v []Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiDeleteServiceProfileByUuidRequest struct {
	ctx context.Context
	ApiService *ServiceProfilesApiService
	serviceProfileId string
	icVersion *string
}

// api version
func (r ApiDeleteServiceProfileByUuidRequest) IcVersion(icVersion string) ApiDeleteServiceProfileByUuidRequest {
	r.icVersion = &icVersion
	return r
}

func (r ApiDeleteServiceProfileByUuidRequest) Execute() (*ServiceProfile, *http.Response, error) {
	return r.ApiService.DeleteServiceProfileByUuidExecute(r)
}

/*
DeleteServiceProfileByUuid Delete Service Profile

This API deletes the service profile of a given layer 2 service profile and an updated response will be received.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param serviceProfileId Service Profile UUID
 @return ApiDeleteServiceProfileByUuidRequest
*/
func (a *ServiceProfilesApiService) DeleteServiceProfileByUuid(ctx context.Context, serviceProfileId string) ApiDeleteServiceProfileByUuidRequest {
	return ApiDeleteServiceProfileByUuidRequest{
		ApiService: a,
		ctx: ctx,
		serviceProfileId: serviceProfileId,
	}
}

// Execute executes the request
//  @return ServiceProfile
func (a *ServiceProfilesApiService) DeleteServiceProfileByUuidExecute(r ApiDeleteServiceProfileByUuidRequest) (*ServiceProfile, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodDelete
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ServiceProfile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ServiceProfilesApiService.DeleteServiceProfileByUuid")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/fabric/v4/serviceProfiles/{serviceProfileId}"
	localVarPath = strings.Replace(localVarPath, "{"+"serviceProfileId"+"}", url.PathEscape(parameterToString(r.serviceProfileId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.icVersion == nil {
		return localVarReturnValue, nil, reportError("icVersion is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json; charset=UTF-8", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["Ic-Version"] = parameterToString(*r.icVersion, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v []Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetAllServiceProfilesRequest struct {
	ctx context.Context
	ApiService *ServiceProfilesApiService
	icVersion *string
	offset *int32
	limit *int32
	viewPoint *string
	style *string
}

// api version
func (r ApiGetAllServiceProfilesRequest) IcVersion(icVersion string) ApiGetAllServiceProfilesRequest {
	r.icVersion = &icVersion
	return r
}

// offset
func (r ApiGetAllServiceProfilesRequest) Offset(offset int32) ApiGetAllServiceProfilesRequest {
	r.offset = &offset
	return r
}

// number of records to fetch
func (r ApiGetAllServiceProfilesRequest) Limit(limit int32) ApiGetAllServiceProfilesRequest {
	r.limit = &limit
	return r
}

// flips view between buyer and seller representation
func (r ApiGetAllServiceProfilesRequest) ViewPoint(viewPoint string) ApiGetAllServiceProfilesRequest {
	r.viewPoint = &viewPoint
	return r
}

// style
func (r ApiGetAllServiceProfilesRequest) Style(style string) ApiGetAllServiceProfilesRequest {
	r.style = &style
	return r
}

func (r ApiGetAllServiceProfilesRequest) Execute() (*ServiceProfiles, *http.Response, error) {
	return r.ApiService.GetAllServiceProfilesExecute(r)
}

/*
GetAllServiceProfiles Get all Profiles

The API request returns all Equinix Fabric Service Profiles in accordance with the view point requested.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiGetAllServiceProfilesRequest
*/
func (a *ServiceProfilesApiService) GetAllServiceProfiles(ctx context.Context) ApiGetAllServiceProfilesRequest {
	return ApiGetAllServiceProfilesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ServiceProfiles
func (a *ServiceProfilesApiService) GetAllServiceProfilesExecute(r ApiGetAllServiceProfilesRequest) (*ServiceProfiles, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ServiceProfiles
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ServiceProfilesApiService.GetAllServiceProfiles")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/fabric/v4/serviceProfiles"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.icVersion == nil {
		return localVarReturnValue, nil, reportError("icVersion is required and must be specified")
	}

	if r.offset != nil {
		localVarQueryParams.Add("offset", parameterToString(*r.offset, ""))
	}
	if r.limit != nil {
		localVarQueryParams.Add("limit", parameterToString(*r.limit, ""))
	}
	if r.viewPoint != nil {
		localVarQueryParams.Add("viewPoint", parameterToString(*r.viewPoint, ""))
	}
	if r.style != nil {
		localVarQueryParams.Add("style", parameterToString(*r.style, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["Ic-Version"] = parameterToString(*r.icVersion, "")
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v []Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiGetServiceProfileByUuidRequest struct {
	ctx context.Context
	ApiService *ServiceProfilesApiService
	serviceProfileId string
	viewPoint *string
	style *string
}

// flips view between buyer and seller representation
func (r ApiGetServiceProfileByUuidRequest) ViewPoint(viewPoint string) ApiGetServiceProfileByUuidRequest {
	r.viewPoint = &viewPoint
	return r
}

// style
func (r ApiGetServiceProfileByUuidRequest) Style(style string) ApiGetServiceProfileByUuidRequest {
	r.style = &style
	return r
}

func (r ApiGetServiceProfileByUuidRequest) Execute() (*ServiceProfile, *http.Response, error) {
	return r.ApiService.GetServiceProfileByUuidExecute(r)
}

/*
GetServiceProfileByUuid Get Service Profile by UUID

This API request retrieves a service profile by UUID and View Point gives sellers view of the profile if set to z-side, otherwise buyers.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param serviceProfileId Service Profile UUID
 @return ApiGetServiceProfileByUuidRequest
*/
func (a *ServiceProfilesApiService) GetServiceProfileByUuid(ctx context.Context, serviceProfileId string) ApiGetServiceProfileByUuidRequest {
	return ApiGetServiceProfileByUuidRequest{
		ApiService: a,
		ctx: ctx,
		serviceProfileId: serviceProfileId,
	}
}

// Execute executes the request
//  @return ServiceProfile
func (a *ServiceProfilesApiService) GetServiceProfileByUuidExecute(r ApiGetServiceProfileByUuidRequest) (*ServiceProfile, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodGet
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ServiceProfile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ServiceProfilesApiService.GetServiceProfileByUuid")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/fabric/v4/serviceProfiles/{serviceProfileId}"
	localVarPath = strings.Replace(localVarPath, "{"+"serviceProfileId"+"}", url.PathEscape(parameterToString(r.serviceProfileId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}

	if r.viewPoint != nil {
		localVarQueryParams.Add("viewPoint", parameterToString(*r.viewPoint, ""))
	}
	if r.style != nil {
		localVarQueryParams.Add("style", parameterToString(*r.style, ""))
	}
	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v []Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v []Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiPutServiceProfileByUuidRequest struct {
	ctx context.Context
	ApiService *ServiceProfilesApiService
	serviceProfileId string
	icVersion *string
	serviceProfileRequest *ServiceProfileRequest
	ifMatch *string
}

// api version
func (r ApiPutServiceProfileByUuidRequest) IcVersion(icVersion string) ApiPutServiceProfileByUuidRequest {
	r.icVersion = &icVersion
	return r
}

func (r ApiPutServiceProfileByUuidRequest) ServiceProfileRequest(serviceProfileRequest ServiceProfileRequest) ApiPutServiceProfileByUuidRequest {
	r.serviceProfileRequest = &serviceProfileRequest
	return r
}

// conditional request
func (r ApiPutServiceProfileByUuidRequest) IfMatch(ifMatch string) ApiPutServiceProfileByUuidRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiPutServiceProfileByUuidRequest) Execute() (*ServiceProfile, *http.Response, error) {
	return r.ApiService.PutServiceProfileByUuidExecute(r)
}

/*
PutServiceProfileByUuid Replace Service Profile

This API replaces Layer 2 service profile definition and an updated response will be received.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param serviceProfileId Service Profile UUID
 @return ApiPutServiceProfileByUuidRequest
*/
func (a *ServiceProfilesApiService) PutServiceProfileByUuid(ctx context.Context, serviceProfileId string) ApiPutServiceProfileByUuidRequest {
	return ApiPutServiceProfileByUuidRequest{
		ApiService: a,
		ctx: ctx,
		serviceProfileId: serviceProfileId,
	}
}

// Execute executes the request
//  @return ServiceProfile
func (a *ServiceProfilesApiService) PutServiceProfileByUuidExecute(r ApiPutServiceProfileByUuidRequest) (*ServiceProfile, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPut
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ServiceProfile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ServiceProfilesApiService.PutServiceProfileByUuid")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/fabric/v4/serviceProfiles/{serviceProfileId}"
	localVarPath = strings.Replace(localVarPath, "{"+"serviceProfileId"+"}", url.PathEscape(parameterToString(r.serviceProfileId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.icVersion == nil {
		return localVarReturnValue, nil, reportError("icVersion is required and must be specified")
	}
	if r.serviceProfileRequest == nil {
		return localVarReturnValue, nil, reportError("serviceProfileRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json; charset=UTF-8", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	localVarHeaderParams["Ic-Version"] = parameterToString(*r.icVersion, "")
	// body params
	localVarPostBody = r.serviceProfileRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v []Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v []Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiSearchServiceProfilesRequest struct {
	ctx context.Context
	ApiService *ServiceProfilesApiService
	icVersion *string
	serviceProfileSearchRequest *ServiceProfileSearchRequest
}

// api version
func (r ApiSearchServiceProfilesRequest) IcVersion(icVersion string) ApiSearchServiceProfilesRequest {
	r.icVersion = &icVersion
	return r
}

func (r ApiSearchServiceProfilesRequest) ServiceProfileSearchRequest(serviceProfileSearchRequest ServiceProfileSearchRequest) ApiSearchServiceProfilesRequest {
	r.serviceProfileSearchRequest = &serviceProfileSearchRequest
	return r
}

func (r ApiSearchServiceProfilesRequest) Execute() (*ServiceProfiles, *http.Response, error) {
	return r.ApiService.SearchServiceProfilesExecute(r)
}

/*
SearchServiceProfiles Service Profile Search

The API request retrieves the list of service profiles matched to the given search criteria.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @return ApiSearchServiceProfilesRequest
*/
func (a *ServiceProfilesApiService) SearchServiceProfiles(ctx context.Context) ApiSearchServiceProfilesRequest {
	return ApiSearchServiceProfilesRequest{
		ApiService: a,
		ctx: ctx,
	}
}

// Execute executes the request
//  @return ServiceProfiles
func (a *ServiceProfilesApiService) SearchServiceProfilesExecute(r ApiSearchServiceProfilesRequest) (*ServiceProfiles, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPost
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ServiceProfiles
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ServiceProfilesApiService.SearchServiceProfiles")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/fabric/v4/serviceProfiles/search"

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.icVersion == nil {
		return localVarReturnValue, nil, reportError("icVersion is required and must be specified")
	}
	if r.serviceProfileSearchRequest == nil {
		return localVarReturnValue, nil, reportError("serviceProfileSearchRequest is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json; charset=UTF-8", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	localVarHeaderParams["Ic-Version"] = parameterToString(*r.icVersion, "")
	// body params
	localVarPostBody = r.serviceProfileSearchRequest
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}

type ApiUpdateServiceProfileByUuidRequest struct {
	ctx context.Context
	ApiService *ServiceProfilesApiService
	serviceProfileId string
	icVersion *string
	jsonPatchOperation *[]JsonPatchOperation
	ifMatch *string
}

// api version
func (r ApiUpdateServiceProfileByUuidRequest) IcVersion(icVersion string) ApiUpdateServiceProfileByUuidRequest {
	r.icVersion = &icVersion
	return r
}

func (r ApiUpdateServiceProfileByUuidRequest) JsonPatchOperation(jsonPatchOperation []JsonPatchOperation) ApiUpdateServiceProfileByUuidRequest {
	r.jsonPatchOperation = &jsonPatchOperation
	return r
}

// conditional request
func (r ApiUpdateServiceProfileByUuidRequest) IfMatch(ifMatch string) ApiUpdateServiceProfileByUuidRequest {
	r.ifMatch = &ifMatch
	return r
}

func (r ApiUpdateServiceProfileByUuidRequest) Execute() (*ServiceProfile, *http.Response, error) {
	return r.ApiService.UpdateServiceProfileByUuidExecute(r)
}

/*
UpdateServiceProfileByUuid Update Service Profile

This API updates service profile definition of a given layer 2 service profile and an updated response will be received.

 @param ctx context.Context - for authentication, logging, cancellation, deadlines, tracing, etc. Passed from http.Request or context.Background().
 @param serviceProfileId Service Profile UUID
 @return ApiUpdateServiceProfileByUuidRequest
*/
func (a *ServiceProfilesApiService) UpdateServiceProfileByUuid(ctx context.Context, serviceProfileId string) ApiUpdateServiceProfileByUuidRequest {
	return ApiUpdateServiceProfileByUuidRequest{
		ApiService: a,
		ctx: ctx,
		serviceProfileId: serviceProfileId,
	}
}

// Execute executes the request
//  @return ServiceProfile
func (a *ServiceProfilesApiService) UpdateServiceProfileByUuidExecute(r ApiUpdateServiceProfileByUuidRequest) (*ServiceProfile, *http.Response, error) {
	var (
		localVarHTTPMethod   = http.MethodPatch
		localVarPostBody     interface{}
		formFiles            []formFile
		localVarReturnValue  *ServiceProfile
	)

	localBasePath, err := a.client.cfg.ServerURLWithContext(r.ctx, "ServiceProfilesApiService.UpdateServiceProfileByUuid")
	if err != nil {
		return localVarReturnValue, nil, &GenericOpenAPIError{error: err.Error()}
	}

	localVarPath := localBasePath + "/fabric/v4/serviceProfiles/{serviceProfileId}"
	localVarPath = strings.Replace(localVarPath, "{"+"serviceProfileId"+"}", url.PathEscape(parameterToString(r.serviceProfileId, "")), -1)

	localVarHeaderParams := make(map[string]string)
	localVarQueryParams := url.Values{}
	localVarFormParams := url.Values{}
	if r.icVersion == nil {
		return localVarReturnValue, nil, reportError("icVersion is required and must be specified")
	}
	if r.jsonPatchOperation == nil {
		return localVarReturnValue, nil, reportError("jsonPatchOperation is required and must be specified")
	}

	// to determine the Content-Type header
	localVarHTTPContentTypes := []string{"application/json-patch+json"}

	// set Content-Type header
	localVarHTTPContentType := selectHeaderContentType(localVarHTTPContentTypes)
	if localVarHTTPContentType != "" {
		localVarHeaderParams["Content-Type"] = localVarHTTPContentType
	}

	// to determine the Accept header
	localVarHTTPHeaderAccepts := []string{"application/json; charset=UTF-8", "application/json"}

	// set Accept header
	localVarHTTPHeaderAccept := selectHeaderAccept(localVarHTTPHeaderAccepts)
	if localVarHTTPHeaderAccept != "" {
		localVarHeaderParams["Accept"] = localVarHTTPHeaderAccept
	}
	if r.ifMatch != nil {
		localVarHeaderParams["If-Match"] = parameterToString(*r.ifMatch, "")
	}
	localVarHeaderParams["Ic-Version"] = parameterToString(*r.icVersion, "")
	// body params
	localVarPostBody = r.jsonPatchOperation
	req, err := a.client.prepareRequest(r.ctx, localVarPath, localVarHTTPMethod, localVarPostBody, localVarHeaderParams, localVarQueryParams, localVarFormParams, formFiles)
	if err != nil {
		return localVarReturnValue, nil, err
	}

	localVarHTTPResponse, err := a.client.callAPI(req)
	if err != nil || localVarHTTPResponse == nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	localVarBody, err := ioutil.ReadAll(localVarHTTPResponse.Body)
	localVarHTTPResponse.Body.Close()
	localVarHTTPResponse.Body = ioutil.NopCloser(bytes.NewBuffer(localVarBody))
	if err != nil {
		return localVarReturnValue, localVarHTTPResponse, err
	}

	if localVarHTTPResponse.StatusCode >= 300 {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: localVarHTTPResponse.Status,
		}
		if localVarHTTPResponse.StatusCode == 400 {
			var v []Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 403 {
			var v []Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
			return localVarReturnValue, localVarHTTPResponse, newErr
		}
		if localVarHTTPResponse.StatusCode == 404 {
			var v []Error
			err = a.client.decode(&v, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
			if err != nil {
				newErr.error = err.Error()
				return localVarReturnValue, localVarHTTPResponse, newErr
			}
			newErr.model = v
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	err = a.client.decode(&localVarReturnValue, localVarBody, localVarHTTPResponse.Header.Get("Content-Type"))
	if err != nil {
		newErr := &GenericOpenAPIError{
			body:  localVarBody,
			error: err.Error(),
		}
		return localVarReturnValue, localVarHTTPResponse, newErr
	}

	return localVarReturnValue, localVarHTTPResponse, nil
}
